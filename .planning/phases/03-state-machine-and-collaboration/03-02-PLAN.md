---
phase: 03-state-machine-and-collaboration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/services/state_service.py
  - backend/services/estado_detalle_builder.py
  - backend/models/state.py
  - backend/routers/occupation.py
  - backend/core/dependency.py
autonomous: true

must_haves:
  truths:
    - "StateService orchestrates both ARM and SOLD state machines"
    - "State machines hydrate from current Sheets columns on initialization"
    - "Estado_Detalle displays combined occupation and operation status"
  artifacts:
    - path: "backend/services/state_service.py"
      provides: "State machine orchestration service"
      min_lines: 150
      exports: ["StateService"]
    - path: "backend/services/estado_detalle_builder.py"
      provides: "Display string formatter"
      min_lines: 50
      exports: ["EstadoDetalleBuilder"]
    - path: "backend/models/state.py"
      provides: "State-related request/response models"
      min_lines: 30
  key_links:
    - from: "state_service.py"
      to: "occupation_service.py"
      via: "dependency injection"
      pattern: "self.occupation_service"
    - from: "state_service.py"
      to: "arm_state_machine.py"
      via: "hydration method"
      pattern: "_hydrate_arm_machine"
---

<objective>
Implement StateService orchestrator that coordinates ARM/SOLD state machines with OccupationService, includes hydration logic to sync with Sheets state, and builds Estado_Detalle display strings.

Purpose: Create the coordination layer that manages multiple state machines per spool and integrates with existing Phase 2 occupation logic.
Output: Working StateService that handles TOMAR/PAUSAR/COMPLETAR with state machine orchestration and Estado_Detalle updates.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-machine-and-collaboration/03-CONTEXT.md
@.planning/phases/03-state-machine-and-collaboration/03-RESEARCH.md
@.planning/phases/03-state-machine-and-collaboration/03-01-SUMMARY.md

# Reference Phase 2 OccupationService
@backend/services/occupation_service.py
@backend/models/occupation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement StateService with hydration logic</name>
  <files>backend/services/state_service.py, backend/models/state.py</files>
  <action>
    Create StateService orchestrator that manages state machines per operation.

    1. Create state_service.py with:
       - Constructor accepting occupation_service, sheets_repo, metadata_repo
       - _hydrate_arm_machine(spool) method that:
         * Creates ARMStateMachine instance
         * Checks spool.fecha_armado → set to completado
         * Else checks spool.armador → set to en_progreso
         * Else remains in pendiente
       - _hydrate_sold_machine(spool) with same pattern
       - Main orchestration methods: tomar(), pausar(), completar()

    2. Create models/state.py with request models if needed

    Follow pattern from 03-RESEARCH.md Example 2 (lines 419-501).
    Focus on hydration logic - callbacks come in Plan 03.
  </action>
  <verify>cd backend && python -c "from services.state_service import StateService; print('StateService imported successfully')"</verify>
  <done>StateService imports without errors</done>
</task>

<task type="auto">
  <name>Task 2: Integrate StateService with OccupationService</name>
  <files>backend/services/state_service.py, backend/routers/occupation.py, backend/core/dependency.py</files>
  <action>
    Wire StateService to work with existing OccupationService from Phase 2.

    1. In state_service.py tomar() method:
       - First call self.occupation_service.tomar() for Redis lock
       - Then hydrate state machines from spool
       - Trigger appropriate state machine transition (iniciar)
       - Update Estado_Detalle (delegate to builder)

    2. Update routers/occupation.py to use StateService instead of OccupationService directly

    3. Add get_state_service() to core/dependency.py

    Maintain Phase 2 Redis locking - StateService wraps OccupationService, doesn't replace it.
  </action>
  <verify>grep -r "StateService" backend/routers/occupation.py backend/core/dependency.py</verify>
  <done>StateService referenced in both router and dependency files</done>
</task>

<task type="auto">
  <name>Task 3: Build Estado_Detalle formatter service</name>
  <files>backend/services/estado_detalle_builder.py</files>
  <action>
    Create service to build consistent Estado_Detalle display strings.

    1. Create EstadoDetalleBuilder class with:
       - build() method accepting: ocupado_por, arm_state, sold_state
       - Format when occupied: "MR(93) trabajando ARM (ARM en progreso, SOLD pendiente)"
       - Format when available: "Disponible - ARM completado, SOLD pendiente"
       - _state_to_display() helper mapping state IDs to Spanish terms

    2. Handle all state combinations:
       - pendiente → "pendiente"
       - en_progreso → "en progreso"
       - completado → "completado"

    Keep formatting logic centralized here, not scattered in StateService.
  </action>
  <verify>cd backend && python -c "from services.estado_detalle_builder import EstadoDetalleBuilder; b = EstadoDetalleBuilder(); print(b.build(None, 'pendiente', 'pendiente'))"</verify>
  <done>Prints "Disponible - ARM pendiente, SOLD pendiente"</done>
</task>

</tasks>

<verification>
1. StateService successfully orchestrates state machines
2. Hydration logic correctly sets state from Sheets columns
3. Integration with OccupationService maintains Redis locking
4. Estado_Detalle builder produces consistent formatted strings
5. Router endpoints use StateService instead of direct OccupationService
</verification>

<success_criteria>
- [ ] StateService created with hydration methods for ARM and SOLD
- [ ] StateService.tomar() delegates to OccupationService then triggers state transitions
- [ ] EstadoDetalleBuilder produces correct display strings for all state combinations
- [ ] Router updated to use StateService through dependency injection
- [ ] Estado_Detalle column populated with formatted strings on TOMAR
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-machine-and-collaboration/03-02-SUMMARY.md`
</output>