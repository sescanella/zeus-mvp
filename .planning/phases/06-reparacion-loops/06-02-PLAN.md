---
phase: 06-reparacion-loops
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/cycle_counter_service.py
  - backend/services/estado_detalle_builder.py
  - backend/services/state_machines/metrologia_state_machine.py
  - backend/services/validation_service.py
  - backend/exceptions.py
  - tests/unit/test_cycle_counter.py
  - tests/unit/test_validation_reparacion.py
autonomous: true

must_haves:
  truths:
    - "Cycle count increments on each metrología RECHAZADO event"
    - "Counter tracks consecutive rejections only and resets after APROBADO"
    - "After 3 consecutive rejections, spool becomes BLOQUEADO"
    - "System prevents TOMAR on BLOQUEADO spools"
  artifacts:
    - path: "backend/services/cycle_counter_service.py"
      provides: "Parse and increment cycle counts from Estado_Detalle"
      exports: ["CycleCounterService"]
    - path: "backend/services/validation_service.py"
      provides: "validar_puede_tomar_reparacion validation"
      min_lines: 30
    - path: "tests/unit/test_cycle_counter.py"
      provides: "Unit tests for cycle counting logic"
      min_lines: 150
  key_links:
    - from: "metrologia_state_machine.py"
      to: "cycle_counter_service.py"
      via: "increment cycle on RECHAZADO"
      pattern: "increment_cycle"
    - from: "validation_service.py"
      to: "exceptions.py"
      via: "raise SpoolBloqueadoError"
      pattern: "SpoolBloqueadoError"
---

<objective>
Implement cycle counting logic that tracks consecutive rejections in Estado_Detalle field, enforcing the 3-cycle limit before blocking spools.

Purpose: Prevent infinite reparación loops by tracking failures and escalating to supervisor after 3 attempts
Output: Working cycle counter with validation that blocks TOMAR after 3 rejections
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-reparacion-loops/06-CONTEXT.md
@.planning/phases/06-reparacion-loops/06-RESEARCH.md

# Reference existing patterns
@backend/services/validation_service.py
@backend/services/estado_detalle_builder.py
@backend/services/state_machines/metrologia_state_machine.py
@backend/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cycle counter service</name>
  <files>backend/services/cycle_counter_service.py</files>
  <action>
    Create CycleCounterService to manage cycle counting without dedicated column:

    1. Define constants:
       - MAX_CYCLES = 3
       - CYCLE_PATTERN = r"Ciclo (\d+)/3"

    2. Implement methods:
       - extract_cycle_count(estado_detalle: str) -> int:
         * Parse cycle from "RECHAZADO (Ciclo X/3)" pattern
         * Return MAX_CYCLES if BLOQUEADO found
         * Return 0 if no cycle info found

       - increment_cycle(current_cycle: int) -> int:
         * Return min(current_cycle + 1, MAX_CYCLES)

       - should_block(current_cycle: int) -> bool:
         * Return True if cycle >= MAX_CYCLES

       - build_rechazado_estado(cycle: int) -> str:
         * If cycle >= MAX_CYCLES: "BLOQUEADO - Contactar supervisor"
         * Else: f"RECHAZADO (Ciclo {cycle}/{MAX_CYCLES}) - Pendiente reparación"

       - build_reparacion_estado(state: str, cycle: int, worker: str = None) -> str:
         * Build estado for EN_REPARACION, REPARACION_PAUSADA states
         * Include cycle info and optional worker name

       - reset_cycle() -> str:
         * Return "METROLOGIA_APROBADO ✓" (no cycle info)

    Reference: Research document pattern examples
    Use compiled regex pattern for performance
  </action>
  <verify>python -m pytest tests/unit/test_cycle_counter.py::test_extract_cycle -xvs</verify>
  <done>CycleCounterService extracts, increments, and formats cycle counts correctly</done>
</task>

<task type="auto">
  <name>Task 2: Extend metrología state machine for cycle counting</name>
  <files>backend/services/state_machines/metrologia_state_machine.py, backend/services/estado_detalle_builder.py</files>
  <action>
    Modify METROLOGIAStateMachine to track and increment cycles:

    1. Update __init__ to accept cycle_counter dependency

    2. Extend on_enter_rechazado callback:
       - Read current Estado_Detalle from sheet
       - Extract current cycle using cycle_counter.extract_cycle_count()
       - Increment cycle using cycle_counter.increment_cycle()
       - Check if should block using cycle_counter.should_block()
       - Build new estado: BLOQUEADO if at limit, else RECHAZADO (Ciclo X/3)
       - Update Estado_Detalle and Fecha_QC_Metrologia columns

    3. Extend on_enter_aprobado callback:
       - Reset cycle counter (use standard APROBADO estado)
       - This breaks consecutive rejection chain

    4. Update EstadoDetalleBuilder.build():
       - Add optional cycle parameter for RECHAZADO states
       - Format: "RECHAZADO (Ciclo X/3) - Pendiente reparación"
       - Add BLOQUEADO state formatting

    Reference: Phase 5 metrologia_state_machine.py structure
    Use batch_update_by_column_name for atomic updates
  </action>
  <verify>python -c "from backend.services.state_machines import METROLOGIAStateMachine; print('Extended machine imports')"</verify>
  <done>Metrología state machine increments cycles on rejection, resets on approval</done>
</task>

<task type="auto">
  <name>Task 3: Add reparación validation and exception</name>
  <files>backend/services/validation_service.py, backend/exceptions.py</files>
  <action>
    Add validation for TOMAR reparación with BLOQUEADO check:

    1. Create SpoolBloqueadoError in exceptions.py:
       - Inherit from ZEUSException
       - HTTP status 403 (Forbidden)
       - Message: "Spool bloqueado después de 3 rechazos. Contactar supervisor."

    2. Add validar_puede_tomar_reparacion() to ValidationService:
       - Check if BLOQUEADO in estado_detalle → raise SpoolBloqueadoError
       - Check if RECHAZADO not in estado_detalle → raise OperacionNoDisponibleError
       - Check if ocupado_por is not None → raise SpoolOccupiedError
       - No role restriction per user decision (any worker can repair)

    3. Add validar_puede_cancelar_reparacion() method:
       - Check if EN_REPARACION or REPARACION_PAUSADA in estado_detalle
       - Check ownership if required

    Reference: Existing validation patterns from Phase 2-3
    Follow consistent error handling pattern with custom exceptions
  </action>
  <verify>python -c "from backend.exceptions import SpoolBloqueadoError; print('Exception created')"</verify>
  <done>Validation prevents TOMAR on BLOQUEADO spools, raises appropriate errors</done>
</task>

<task type="auto">
  <name>Task 4: Create comprehensive tests</name>
  <files>tests/unit/test_cycle_counter.py, tests/unit/test_validation_reparacion.py</files>
  <action>
    Create unit tests for cycle counting and validation:

    test_cycle_counter.py:
    1. Test extraction:
       - test_extract_cycle_from_rechazado_estado
       - test_extract_returns_max_for_bloqueado
       - test_extract_returns_zero_for_no_cycle

    2. Test increment:
       - test_increment_cycle_normal
       - test_increment_caps_at_max

    3. Test blocking logic:
       - test_should_block_at_max_cycles
       - test_should_not_block_below_max

    4. Test estado building:
       - test_build_rechazado_with_cycle
       - test_build_bloqueado_at_limit
       - test_reset_cycle_removes_info

    test_validation_reparacion.py:
    1. Test BLOQUEADO validation:
       - test_cannot_tomar_bloqueado_spool
       - test_can_tomar_rechazado_spool

    2. Test occupation validation:
       - test_cannot_tomar_occupied_spool

    3. Test estado validation:
       - test_cannot_repair_non_rechazado_spool

    Use parametrize for multiple test cases
    Mock Spool objects with different estados
  </action>
  <verify>python -m pytest tests/unit/test_cycle_counter.py tests/unit/test_validation_reparacion.py -v</verify>
  <done>All cycle counting and validation tests passing (15+ tests)</done>
</task>

</tasks>

<verification>
# Run cycle counter tests
python -m pytest tests/unit/test_cycle_counter.py -v

# Run validation tests
python -m pytest tests/unit/test_validation_reparacion.py -v

# Verify cycle pattern extraction
python -c "from backend.services.cycle_counter_service import CycleCounterService; c = CycleCounterService(); print(c.extract_cycle_count('RECHAZADO (Ciclo 2/3)'))"

# Check SpoolBloqueadoError exists
python -c "from backend.exceptions import SpoolBloqueadoError; print(SpoolBloqueadoError.__name__)"
</verification>

<success_criteria>
- [ ] CycleCounterService correctly parses "Ciclo X/3" from Estado_Detalle
- [ ] Cycle increments only on RECHAZADO, resets on APROBADO
- [ ] After 3rd rejection, estado becomes BLOQUEADO
- [ ] SpoolBloqueadoError raised when trying to TOMAR BLOQUEADO spool
- [ ] All unit tests pass for cycle counting and validation
- [ ] Metrología state machine integrates cycle counter correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-reparacion-loops/06-02-SUMMARY.md`
</output>