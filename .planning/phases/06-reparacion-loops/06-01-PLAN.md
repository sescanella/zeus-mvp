---
phase: 06-reparacion-loops
plan: 01
type: execute
wave: 2
depends_on: [06-02]
files_modified:
  - backend/services/state_machines/reparacion_state_machine.py
  - backend/services/state_machines/__init__.py
  - backend/models/enums.py
  - backend/services/reparacion_service.py
  - backend/services/__init__.py
  - tests/unit/test_reparacion_machine.py
autonomous: true

must_haves:
  truths:
    - "ReparacionStateMachine has 4 states: RECHAZADO, EN_REPARACION, REPARACION_PAUSADA, PENDIENTE_METROLOGIA"
    - "Worker can TOMAR spool with estado RECHAZADO for repair"
    - "Worker can PAUSAR repair work and release occupation"
    - "COMPLETAR repair returns spool to metrología queue automatically"
  artifacts:
    - path: "backend/services/state_machines/reparacion_state_machine.py"
      provides: "4-state machine for reparación workflow"
      min_lines: 120
    - path: "backend/services/reparacion_service.py"
      provides: "Service orchestrating reparación workflow"
      exports: ["ReparacionService"]
    - path: "tests/unit/test_reparacion_machine.py"
      provides: "Unit tests for state transitions"
      min_lines: 200
  key_links:
    - from: "reparacion_state_machine.py"
      to: "sheets_repository.py"
      via: "column updates on state transitions"
      pattern: "batch_update_by_column_name"
    - from: "reparacion_service.py"
      to: "reparacion_state_machine.py"
      via: "state machine instantiation"
      pattern: "REPARACIONStateMachine"
    - from: "reparacion_service.py"
      to: "cycle_counter_service.py"
      via: "cycle parsing and validation"
      pattern: "CycleCounterService"
---

<objective>
Implement the reparación state machine with 4 states following the Phase 3 pattern, enabling workers to repair rejected spools with TOMAR/PAUSAR/COMPLETAR actions.

Purpose: Create the foundation for bounded repair cycles that prevent infinite RECHAZADO → reparación loops
Output: Working state machine with callbacks that update Google Sheets columns on transitions
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-reparacion-loops/06-CONTEXT.md
@.planning/phases/06-reparacion-loops/06-RESEARCH.md
@.planning/phases/05-metrologia-workflow/05-04-SUMMARY.md
@.planning/phases/06-reparacion-loops/06-02-SUMMARY.md

# Reference existing state machine patterns
@backend/services/state_machines/base_state_machine.py
@backend/services/state_machines/arm_state_machine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reparación state machine</name>
  <files>backend/services/state_machines/reparacion_state_machine.py, backend/services/state_machines/__init__.py, backend/models/enums.py</files>
  <action>
    Create REPARACIONStateMachine with 4 states following the ARM/SOLD pattern from Phase 3:

    1. Define states:
       - rechazado (initial): Failed metrología, awaiting repair
       - en_reparacion: Worker actively repairing
       - reparacion_pausada: Worker paused mid-repair
       - pendiente_metrologia (final): Repair complete, ready for re-inspection

    2. Define transitions:
       - tomar: rechazado → en_reparacion, reparacion_pausada → en_reparacion
       - pausar: en_reparacion → reparacion_pausada
       - completar: en_reparacion → pendiente_metrologia
       - cancelar: en_reparacion/reparacion_pausada → rechazado

    3. Implement callbacks:
       - on_enter_en_reparacion: Set Ocupado_Por, Fecha_Ocupacion, update Estado_Detalle with cycle info
       - on_enter_reparacion_pausada: Clear occupation fields, set Estado_Detalle to REPARACION_PAUSADA (Ciclo X/3)
       - on_enter_pendiente_metrologia: Clear occupation, set Estado_Detalle to PENDIENTE_METROLOGIA
       - on_enter_rechazado (cancelar): Clear occupation, restore RECHAZADO estado with cycle

    4. Add REPARACION to ActionType enum in models/enums.py

    5. Export REPARACIONStateMachine from __init__.py

    Reference: Phase 3 ARM state machine pattern, using batch_update_by_column_name for Sheets updates
    Avoid: Creating new columns - use Estado_Detalle for cycle info as per user decision
  </action>
  <verify>python -m pytest tests/unit/test_reparacion_machine.py::test_state_transitions -xvs</verify>
  <done>State machine transitions work: RECHAZADO → EN_REPARACION → PENDIENTE_METROLOGIA</done>
</task>

<task type="auto">
  <name>Task 2: Create reparación service</name>
  <files>backend/services/reparacion_service.py, backend/services/__init__.py</files>
  <action>
    Create ReparacionService orchestrating the workflow, following Phase 3 StateService pattern:

    1. Inject dependencies: sheets_repo, metadata_repo, redis_repo, cycle_counter_service

    2. Import and inject CycleCounterService from Plan 06-02:
       - from backend.services.cycle_counter_service import CycleCounterService
       - self.cycle_counter = cycle_counter_service

    3. Implement core methods:
       - tomar_reparacion(tag_spool, worker_id, worker_nombre):
         * Parse cycle count: self.cycle_counter.extract_cycle_count(estado_detalle)
         * Check not BLOQUEADO: self.cycle_counter.should_block(current_cycle)
         * Instantiate REPARACIONStateMachine
         * Execute tomar transition with cycle from Estado_Detalle
         * Log TOMAR_REPARACION event to Metadata

       - pausar_reparacion(tag_spool, worker_id):
         * Verify ownership
         * Execute pausar transition
         * Log PAUSAR_REPARACION event

       - completar_reparacion(tag_spool, worker_id):
         * Verify ownership
         * Execute completar transition (auto-queues for metrología)
         * Log COMPLETAR_REPARACION event

       - cancelar_reparacion(tag_spool, worker_id):
         * Execute cancelar transition
         * Log CANCELAR_REPARACION event

    4. Export from __init__.py

    Reference: Phase 3 StateService.handle_action() pattern
    Use CycleCounterService from Plan 06-02 for all cycle parsing and validation
  </action>
  <verify>python -c "from backend.services import ReparacionService; print('Service imported successfully')"</verify>
  <done>ReparacionService created with TOMAR/PAUSAR/COMPLETAR/CANCELAR methods using CycleCounterService</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive unit tests</name>
  <files>tests/unit/test_reparacion_machine.py</files>
  <action>
    Create unit tests for reparación state machine following Phase 3 test patterns:

    1. Test state transitions:
       - test_tomar_from_rechazado: RECHAZADO → EN_REPARACION
       - test_pausar_from_en_reparacion: EN_REPARACION → REPARACION_PAUSADA
       - test_reanudar_from_pausada: REPARACION_PAUSADA → EN_REPARACION
       - test_completar_to_pendiente_metrologia: EN_REPARACION → PENDIENTE_METROLOGIA
       - test_cancelar_to_rechazado: Both EN_REPARACION and REPARACION_PAUSADA → RECHAZADO

    2. Test invalid transitions:
       - test_cannot_completar_from_pausada: Must resume first
       - test_cannot_pausar_from_rechazado: Must TOMAR first

    3. Test column updates (mock sheets_repo):
       - test_tomar_updates_occupation_columns
       - test_pausar_clears_occupation
       - test_completar_sets_pendiente_metrologia
       - test_estado_detalle_includes_cycle_info

    4. Test terminal state:
       - test_pendiente_metrologia_is_final_state

    Use pytest fixtures for reusable machine setup
    Mock sheets_repository for column update verification
  </action>
  <verify>python -m pytest tests/unit/test_reparacion_machine.py -v</verify>
  <done>All reparación state machine tests passing (10+ tests)</done>
</task>

</tasks>

<verification>
# Run all unit tests for reparación
python -m pytest tests/unit/test_reparacion_machine.py -v

# Verify state machine can be imported
python -c "from backend.services.state_machines import REPARACIONStateMachine"

# Verify service can be instantiated
python -c "from backend.services import ReparacionService"

# Check ActionType enum includes REPARACION
python -c "from backend.models.enums import ActionType; print('REPARACION' in ActionType.__members__)"
</verification>

<success_criteria>
- [ ] REPARACIONStateMachine has 4 states with proper transitions
- [ ] TOMAR/PAUSAR/COMPLETAR/CANCELAR transitions work correctly
- [ ] Estado_Detalle updates include cycle info (Ciclo X/3)
- [ ] COMPLETAR sets estado to PENDIENTE_METROLOGIA (auto-queue for re-inspection)
- [ ] Unit tests pass with 100% state machine coverage
- [ ] ActionType enum includes REPARACION value
- [ ] ReparacionService uses CycleCounterService for cycle validation
</success_criteria>

<output>
After completion, create `.planning/phases/06-reparacion-loops/06-01-SUMMARY.md`
</output>