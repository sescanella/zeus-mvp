---
phase: 09-redis-version-detection
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/version_detection_service.py
  - backend/routers/diagnostic.py
  - backend/models/version.py
  - backend/decorators/version_validator.py
autonomous: true

must_haves:
  truths:
    - "System detects v3.0 vs v4.0 based on Total_Uniones column"
    - "Version detection has retry logic with exponential backoff"
    - "Detection failures default to v3.0 workflow"
    - "v4.0 endpoints reject v3.0 spools with 422 error"
  artifacts:
    - path: "backend/services/version_detection_service.py"
      provides: "Version detection with retry logic"
      min_lines: 100
    - path: "backend/routers/diagnostic.py"
      provides: "Version diagnostic endpoint"
      exports: ["router"]
    - path: "backend/models/version.py"
      provides: "Version response models"
      contains: "VersionInfo"
    - path: "backend/decorators/version_validator.py"
      provides: "Version validation decorator"
      exports: ["require_v4_spool"]
  key_links:
    - from: "version_detection_service.py"
      to: "Total_Uniones"
      via: "column 68 query"
      pattern: "total_uniones"
    - from: "version_validator.py"
      to: "version_detection_service.py"
      via: "decorator injection"
      pattern: "detect_version"
---

<objective>
Create version detection service to identify v3.0 vs v4.0 spools based on union count, with validation decorator for v4.0 endpoints.

Purpose: Enable dual workflow routing by detecting spool version from Total_Uniones column and enforcing version requirements.
Output: Service that queries column 68 with retry logic, diagnostic endpoint, and validation decorator for v4.0 endpoints.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-version-detection/09-CONTEXT.md
@.planning/phases/09-redis-version-detection/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create version detection service</name>
  <files>backend/services/version_detection_service.py</files>
  <action>
    Create VersionDetectionService class with retry logic:

    1. Constructor accepts sheets_repository
    2. detect_version(tag_spool: str) method:
       - Query spool from Operaciones sheet
       - Get total_uniones value (column 68, may be None or 0)
       - Determine version: v4.0 if count > 0, v3.0 if count = 0
       - Return dict with: version, union_count, detection_logic
    3. Apply @retry decorator from tenacity:
       - 3 attempts max
       - Exponential backoff (2s, 4s, 10s max)
       - Retry on SheetsConnectionError, TimeoutError
       - Log warnings on retry attempts
    4. On failure after retries:
       - Default to v3.0 (safer legacy workflow)
       - Include error in detection_logic field

    Reference: 09-RESEARCH.md Pattern 4 for retry configuration.

    ```python
    from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((SheetsConnectionError, TimeoutError)),
        reraise=True
    )
    async def detect_version(self, tag_spool: str) -> dict:
        # Implementation here
    ```
  </action>
  <verify>python -c "from backend.services.version_detection_service import VersionDetectionService; print('Import successful')"</verify>
  <done>VersionDetectionService detects version with retry logic</done>
</task>

<task type="auto">
  <name>Task 2: Create version models</name>
  <files>backend/models/version.py</files>
  <action>
    Create Pydantic models for version detection:

    1. VersionInfo model:
       - version: Literal["v3.0", "v4.0"]
       - union_count: int (from Total_Uniones)
       - detection_logic: str (explanation)
       - tag_spool: str
    2. VersionResponse model:
       - success: bool
       - data: VersionInfo
    3. VersionMismatchError model:
       - error: str = "Version mismatch"
       - message: str (detailed error)
       - expected_version: str
       - actual_version: str
       - tag_spool: str
    4. Field validation:
       - union_count >= 0
       - version must be v3.0 or v4.0

    Use Pydantic v2 syntax with field validators.
  </action>
  <verify>python -c "from backend.models.version import VersionInfo, VersionResponse, VersionMismatchError; print('Models imported')"</verify>
  <done>Version models define API response structure including error model</done>
</task>

<task type="auto">
  <name>Task 3: Create version validation decorator</name>
  <files>backend/decorators/version_validator.py</files>
  <action>
    Create decorator to validate spool version for v4.0 endpoints:

    1. require_v4_spool() decorator:
       - Extract tag_spool from request (path/body)
       - Call version_detection_service.detect_version()
       - If version != "v4.0":
         - Return 422 Unprocessable Entity
         - Body: VersionMismatchError model
       - If version == "v4.0":
         - Allow request to proceed
    2. Inject version info into request state for endpoint use
    3. Handle detection failures gracefully (allow v3.0 default)

    ```python
    from functools import wraps
    from fastapi import HTTPException, Request, Depends

    def require_v4_spool(version_service: VersionDetectionService = Depends()):
        def decorator(func):
            @wraps(func)
            async def wrapper(request: Request, *args, **kwargs):
                # Extract tag_spool from request
                tag_spool = kwargs.get('tag_spool') or request.json().get('tag_spool')

                # Detect version
                version_info = await version_service.detect_version(tag_spool)

                # Validate v4.0
                if version_info['version'] != 'v4.0':
                    raise HTTPException(
                        status_code=422,
                        detail=VersionMismatchError(
                            message=f"This endpoint requires v4.0 spools with unions. Spool {tag_spool} is {version_info['version']}",
                            expected_version="v4.0",
                            actual_version=version_info['version'],
                            tag_spool=tag_spool
                        ).dict()
                    )

                # Inject version info
                request.state.version_info = version_info
                return await func(request, *args, **kwargs)
            return wrapper
        return decorator
    ```
  </action>
  <verify>python -c "from backend.decorators.version_validator import require_v4_spool; print('Decorator imported')"</verify>
  <done>require_v4_spool decorator validates v4.0 spools and returns 422 for version mismatch</done>
</task>

<task type="auto">
  <name>Task 4: Create diagnostic endpoint</name>
  <files>backend/routers/diagnostic.py</files>
  <action>
    Create diagnostic router with version detection endpoint:

    1. GET /api/diagnostic/{tag}/version endpoint:
       - Path parameter: tag (spool identifier)
       - Call version_detection_service.detect_version()
       - Return VersionResponse with detailed info
    2. Error handling:
       - 404 if spool not found
       - 503 if Sheets unavailable
       - 200 with default v3.0 if detection fails
    3. Add logging for diagnostics
    4. Include router in main.py (app.include_router)

    Use FastAPI dependency injection for version_detection_service.

    ```python
    @router.get("/{tag}/version", response_model=VersionResponse)
    async def get_spool_version(
        tag: str,
        version_service: VersionDetectionService = Depends(get_version_service)
    ):
        # Implementation here
    ```
  </action>
  <verify>curl -X GET http://localhost:8000/api/diagnostic/TEST-01/version</verify>
  <done>Diagnostic endpoint returns version detection details</done>
</task>

</tasks>

<verification>
- VersionDetectionService queries Total_Uniones (column 68)
- Version is v4.0 if union_count > 0, v3.0 if 0
- Retry logic handles transient failures (3 attempts, exponential backoff)
- require_v4_spool decorator validates version and returns 422 for mismatch
- Diagnostic endpoint provides transparency into detection logic
- Detection failures default to v3.0 workflow
</verification>

<success_criteria>
- [ ] detect_version() queries total_uniones from Operaciones sheet
- [ ] Method applies v4.0 if count > 0, v3.0 if count = 0
- [ ] Retry decorator configured with 3 attempts and exponential backoff
- [ ] require_v4_spool decorator returns 422 for v3.0 spools on v4.0 endpoints
- [ ] GET /api/diagnostic/{tag}/version returns detailed version info
- [ ] Detection failures default to v3.0 with error in detection_logic
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-version-detection/09-04-SUMMARY.md`
</output>