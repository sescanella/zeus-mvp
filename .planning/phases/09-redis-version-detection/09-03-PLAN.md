---
phase: 09-redis-version-detection
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - backend/main.py
  - backend/services/redis_lock_service.py
autonomous: true

must_haves:
  truths:
    - "FastAPI startup reconciles Redis locks from Sheets"
    - "Missing Redis locks are recreated from Sheets.Ocupado_Por"
    - "Locks older than 24h are not recreated"
  artifacts:
    - path: "backend/main.py"
      provides: "Startup reconciliation logic"
      contains: "reconcile_redis_locks"
    - path: "backend/services/redis_lock_service.py"
      provides: "Reconciliation helper methods"
      exports: ["reconcile_from_sheets"]
  key_links:
    - from: "main.py"
      to: "redis_lock_service.py"
      via: "startup_event"
      pattern: "await.*reconcile"
---

<objective>
Implement startup reconciliation to rebuild Redis locks from Sheets.Ocupado_Por.

Purpose: Auto-recover from Redis crashes or Railway restarts by treating Sheets as source of truth.
Output: FastAPI startup event that recreates missing Redis locks from occupied spools in Sheets.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-version-detection/09-CONTEXT.md
@.planning/phases/09-redis-version-detection/09-RESEARCH.md
@.planning/phases/09-redis-version-detection/09-01-SUMMARY.md
@.planning/phases/09-redis-version-detection/09-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconciliation method to Redis lock service</name>
  <files>backend/services/redis_lock_service.py</files>
  <action>
    Add reconcile_from_sheets() method to RedisLockService:

    1. Accept sheets_repository as parameter
    2. Query all spools from Operaciones sheet
    3. Filter spools where ocupado_por is not None and not "DISPONIBLE"
    4. For each occupied spool:
       - Parse fecha_ocupacion to check age
       - Skip if older than 24 hours (stale occupation)
       - Check if Redis lock exists using redis.exists()
       - If lock missing:
         - Parse worker_id from "INICIALES(ID)" format using regex
         - Create lock value: "{worker_id}:{uuid}:{fecha_ocupacion}"
         - Acquire with safety TTL (10 seconds)
         - Call persist() to make permanent
         - Log reconciliation action
    5. Return counts: {reconciled: N, skipped: M}

    Use async with timeout to prevent blocking startup too long.
    Reference: 09-RESEARCH.md Pattern 3 for implementation.
  </action>
  <verify>grep "reconcile_from_sheets" backend/services/redis_lock_service.py</verify>
  <done>reconcile_from_sheets() recreates missing locks from Sheets data</done>
</task>

<task type="auto">
  <name>Task 2: Call reconciliation from FastAPI startup</name>
  <files>backend/main.py</files>
  <action>
    Modify startup_event() to call reconciliation after Redis connection:

    1. After successful Redis connection (line ~273)
    2. Create RedisLockService with redis_client and sheets_repository
    3. Call reconcile_from_sheets() with timeout (10 seconds max)
    4. Log results: reconciled count, skipped count
    5. Wrap in try/except - if reconciliation fails, log warning but continue

    Place after Redis connection but before schema validation:
    ```python
    # v4.0: Reconcile Redis locks from Sheets (auto-recovery)
    try:
        from backend.services.redis_lock_service import RedisLockService
        lock_service = RedisLockService(redis_repo.client, sheets_repo)

        # Reconcile with timeout
        import asyncio
        results = await asyncio.wait_for(
            lock_service.reconcile_from_sheets(sheets_repo),
            timeout=10.0
        )

        logging.info(f"✅ Redis reconciliation complete: {results['reconciled']} locks created, {results['skipped']} old locks skipped")
    except asyncio.TimeoutError:
        logging.warning("⚠️ Redis reconciliation timed out after 10s. Locks will be created on-demand.")
    except Exception as e:
        logging.warning(f"⚠️ Redis reconciliation failed: {e}. Locks will be created on-demand.")
    ```
  </action>
  <verify>grep "reconcile" backend/main.py</verify>
  <done>startup_event calls reconciliation with timeout handling</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for reconciliation</name>
  <files>tests/integration/test_startup_reconciliation.py</files>
  <action>
    Create integration tests for startup reconciliation:

    1. Test reconciliation creates locks for occupied spools
    2. Test reconciliation skips spools older than 24h
    3. Test reconciliation skips spools with existing locks
    4. Test reconciliation timeout handling (simulated slow Sheets query)
    5. Test reconciliation failure doesn't block startup

    Use real Redis test instance if available, or mock Redis operations.
    Mock Sheets data to control test scenarios.

    Verify correct locks are created and counts are accurate.
  </action>
  <verify>pytest tests/integration/test_startup_reconciliation.py -v</verify>
  <done>Integration tests pass for all reconciliation scenarios</done>
</task>

</tasks>

<verification>
- reconcile_from_sheets() queries all occupied spools from Sheets
- Missing Redis locks are recreated with proper format
- Locks older than 24h are skipped (not recreated)
- Startup reconciliation has timeout to prevent blocking
- Reconciliation failure doesn't prevent API startup
</verification>

<success_criteria>
- [ ] reconcile_from_sheets() filters by ocupado_por != "DISPONIBLE"
- [ ] Method skips occupations older than 24 hours
- [ ] Missing locks are created using two-step approach (SET + PERSIST)
- [ ] startup_event() calls reconciliation with 10-second timeout
- [ ] Integration tests verify correct lock recreation
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-version-detection/09-03-SUMMARY.md`
</output>