---
phase: 09-redis-version-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/redis_lock_service.py
  - backend/routers/occupation.py
autonomous: true

must_haves:
  truths:
    - "INICIAR cleans up one abandoned lock per operation"
    - "Abandoned locks are >24h old without matching Sheets.Ocupado_Por"
    - "Cleanup happens before lock acquisition"
  artifacts:
    - path: "backend/services/redis_lock_service.py"
      provides: "Lazy cleanup mechanism"
      exports: ["lazy_cleanup_one_abandoned_lock"]
    - path: "backend/routers/occupation.py"
      provides: "INICIAR with inline cleanup"
      contains: "lazy_cleanup"
  key_links:
    - from: "occupation.py"
      to: "redis_lock_service.py"
      via: "lazy_cleanup_one_abandoned_lock()"
      pattern: "await.*lazy_cleanup_one_abandoned_lock"
---

<objective>
Implement lazy cleanup mechanism to remove abandoned locks during INICIAR operations.

Purpose: Prevent permanent deadlocks from persistent locks by cleaning up abandoned locks >24h old.
Output: Lazy cleanup that removes one abandoned lock per INICIAR operation for eventual consistency.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-version-detection/09-CONTEXT.md
@.planning/phases/09-redis-version-detection/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lazy cleanup in Redis lock service</name>
  <files>backend/services/redis_lock_service.py</files>
  <action>
    Add lazy_cleanup_one_abandoned_lock() method to RedisLockService:

    1. Use redis.scan() with pattern "spool_lock:*" and count=10
    2. Extract first lock key found
    3. Parse TAG_SPOOL from key format "spool_lock:{tag}"
    4. Get lock value and extract timestamp (format: "{worker_id}:{token}:{timestamp}")
    5. Calculate age using now_chile() from date_formatter
    6. If age > 24 hours:
       - Query Sheets for spool.ocupado_por via sheets_repository
       - If ocupado_por is None or "DISPONIBLE":
         - Delete lock silently (no Metadata event)
         - Log cleanup action
    7. Return early after checking one lock (eventual consistency)

    Important: Process only ONE lock per call to avoid blocking operations.
    Reference: 09-RESEARCH.md Pattern 2 for implementation details.

    Add sheets_repository parameter to constructor for Sheets queries.
  </action>
  <verify>grep "lazy_cleanup_one_abandoned_lock" backend/services/redis_lock_service.py</verify>
  <done>lazy_cleanup_one_abandoned_lock() scans and cleans one abandoned lock</done>
</task>

<task type="auto">
  <name>Task 2: Call cleanup from INICIAR endpoint</name>
  <files>backend/routers/occupation.py</files>
  <action>
    Modify the INICIAR endpoint (or iniciar_spool if v4.0 endpoint exists) to call cleanup:

    1. Before acquiring new lock, call lazy_cleanup_one_abandoned_lock()
    2. Wrap in try/except - if cleanup fails, log warning but continue
    3. Order: cleanup → acquire → persist (prevents cleaning own lock)

    The cleanup should be inline, not async/background:
    ```python
    # Lazy cleanup (best effort, don't block on failure)
    try:
        await lock_service.lazy_cleanup_one_abandoned_lock()
    except Exception as e:
        logger.warning(f"Lazy cleanup failed: {e}")

    # Continue with lock acquisition
    lock_token = await lock_service.acquire_lock(...)
    ```

    If INICIAR endpoint doesn't exist yet, add cleanup to tomar_spool() for now.
  </action>
  <verify>grep "lazy_cleanup" backend/routers/occupation.py</verify>
  <done>INICIAR/tomar calls lazy cleanup before lock acquisition</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for lazy cleanup</name>
  <files>tests/unit/test_lazy_cleanup.py</files>
  <action>
    Create unit tests for lazy cleanup mechanism:

    1. Test cleanup of lock >24h old with no Sheets match
    2. Test skip of lock <24h old
    3. Test skip of lock with matching Sheets.Ocupado_Por
    4. Test cleanup processes only one lock per call
    5. Test cleanup failure doesn't block INICIAR

    Mock:
    - redis.scan() to return test lock keys
    - redis.get() to return lock values with timestamps
    - sheets_repository.get_spool_by_tag() to return test spools
    - now_chile() to control time calculations

    Verify cleanup deletes correct locks and logs appropriately.
  </action>
  <verify>pytest tests/unit/test_lazy_cleanup.py -v</verify>
  <done>Unit tests pass for all lazy cleanup scenarios</done>
</task>

</tasks>

<verification>
- lazy_cleanup_one_abandoned_lock() identifies locks >24h old
- Cleanup queries Sheets to verify occupation status
- Only abandoned locks (no Sheets match) are deleted
- Cleanup processes exactly one lock per call
- INICIAR calls cleanup before lock acquisition
</verification>

<success_criteria>
- [ ] lazy_cleanup_one_abandoned_lock() uses SCAN with limit=1
- [ ] Cleanup checks lock age > 24 hours using timestamp from lock value
- [ ] Cleanup verifies Sheets.Ocupado_Por before deleting
- [ ] INICIAR/tomar endpoint calls cleanup inline (not async)
- [ ] Unit tests verify one-lock-per-operation behavior
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-version-detection/09-02-SUMMARY.md`
</output>