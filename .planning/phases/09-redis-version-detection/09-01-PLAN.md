---
phase: 09-redis-version-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/redis_lock_service.py
  - backend/config.py
  - backend/utils/date_formatter.py
autonomous: true

must_haves:
  truths:
    - "Redis locks persist indefinitely until explicitly released"
    - "INICIAR creates persistent locks without TTL"
    - "FINALIZAR releases persistent locks regardless of time"
    - "System operates in degraded mode when Redis unavailable"
  artifacts:
    - path: "backend/services/redis_lock_service.py"
      provides: "Persistent lock acquisition with PERSIST command and fallback"
      min_lines: 450
    - path: "backend/config.py"
      provides: "Configuration for persistent locks"
      contains: "REDIS_PERSISTENT_LOCKS"
  key_links:
    - from: "redis_lock_service.py"
      to: "redis.persist()"
      via: "Two-step acquisition"
      pattern: "persist\\(lock_key\\)"
    - from: "redis_lock_service.py"
      to: "sheets_repository"
      via: "Degraded mode fallback"
      pattern: "ocupado_por.*DISPONIBLE"
---

<objective>
Implement persistent Redis locks without TTL to support long-running work sessions (5-8 hours), with degraded mode fallback.

Purpose: Enable workers to hold locks indefinitely during extended work periods without timeout issues.
Output: Modified Redis lock service with two-step acquisition (SET with safety TTL, then PERSIST) and Sheets-only fallback.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-version-detection/09-CONTEXT.md
@.planning/phases/09-redis-version-detection/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistent lock configuration</name>
  <files>backend/config.py</files>
  <action>
    Add configuration flags for persistent locks to config.py:
    - Add REDIS_PERSISTENT_LOCKS = True flag (v4.0 mode)
    - Add REDIS_SAFETY_TTL = 10 seconds (for initial acquisition)
    - Keep REDIS_LOCK_TTL_SECONDS for backward compatibility (v3.0 mode)

    This allows toggling between v3.0 TTL mode and v4.0 persistent mode via environment variable.
  </action>
  <verify>grep "REDIS_PERSISTENT_LOCKS" backend/config.py</verify>
  <done>Config has REDIS_PERSISTENT_LOCKS and REDIS_SAFETY_TTL settings</done>
</task>

<task type="auto">
  <name>Task 2: Implement two-step persistent lock acquisition</name>
  <files>backend/services/redis_lock_service.py</files>
  <action>
    Modify acquire_lock() method to support persistent locks:

    1. Add timestamp to lock value format: "{worker_id}:{token}:{timestamp}"
    2. Check REDIS_PERSISTENT_LOCKS flag from config
    3. If persistent mode:
       - Acquire with safety TTL (10 seconds)
       - If acquired, immediately call redis.persist(lock_key)
       - Check persist result (1 = success, 0 = key missing)
       - Handle persist failure by releasing and raising error
    4. If TTL mode (v3.0 compatibility):
       - Keep existing behavior (SET NX EX with full TTL)

    Update _lock_value() method to include timestamp using format_datetime_for_sheets().
    Update _parse_lock_value() to handle new format with backward compatibility.

    Reference: 09-RESEARCH.md Pattern 1 for two-step approach details.
  </action>
  <verify>python -c "from backend.services.redis_lock_service import RedisLockService; print('Import successful')"</verify>
  <done>acquire_lock() supports both TTL and persistent modes with two-step acquisition</done>
</task>

<task type="auto">
  <name>Task 3: Implement degraded mode for Redis unavailability</name>
  <files>backend/services/redis_lock_service.py</files>
  <action>
    Add degraded mode operation when Redis is unavailable:

    1. Wrap Redis operations in try/except blocks
    2. On Redis connection error or timeout:
       - Log warning about degraded mode
       - Fall back to Sheets-only operation
       - Update Sheets.Ocupado_Por directly without Redis lock
       - Return special token indicating degraded mode: "DEGRADED:{worker_id}:{timestamp}"
    3. For release_lock() in degraded mode:
       - Check if token starts with "DEGRADED:"
       - If yes, only clear Sheets.Ocupado_Por (no Redis operation)
    4. Add method is_degraded_mode(token) to check if operating without Redis

    This ensures system remains operational even if Redis completely fails.
    Reference: User decision "Redis unavailability: Operate in Sheets-only mode"
  </action>
  <verify>grep "DEGRADED:" backend/services/redis_lock_service.py</verify>
  <done>Service falls back to Sheets-only operation when Redis unavailable</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for persistent locks and degraded mode</name>
  <files>tests/unit/test_redis_lock_service.py</files>
  <action>
    Create comprehensive unit tests for persistent lock behavior:

    1. Test two-step acquisition (SET then PERSIST)
    2. Test persist failure handling (key expires between SET and PERSIST)
    3. Test backward compatibility with TTL mode
    4. Test lock value format with timestamp
    5. Test release still works with new format
    6. Test degraded mode fallback when Redis unavailable
    7. Test degraded mode token format and handling

    Mock redis.persist() to return 1 for success, 0 for failure cases.
    Mock redis connection errors to test degraded mode.
    Test both REDIS_PERSISTENT_LOCKS=True and False configurations.

    Use pytest and asyncio for async test methods.
  </action>
  <verify>pytest tests/unit/test_redis_lock_service.py -v</verify>
  <done>Unit tests pass for persistent lock acquisition, persist failure, degraded mode, and backward compatibility</done>
</task>

</tasks>

<verification>
- Redis locks can be acquired without TTL in persistent mode
- Lock value includes timestamp for age detection
- Two-step acquisition prevents orphaned locks
- System falls back to Sheets-only when Redis unavailable
- v3.0 TTL mode still works when REDIS_PERSISTENT_LOCKS=False
- Unit tests cover all edge cases including degraded mode
</verification>

<success_criteria>
- [ ] Config has REDIS_PERSISTENT_LOCKS flag (default True for v4.0)
- [ ] acquire_lock() uses two-step approach: SET with safety TTL, then PERSIST
- [ ] Lock value format includes timestamp: "{worker_id}:{token}:{timestamp}"
- [ ] Degraded mode operates using Sheets-only when Redis fails
- [ ] Backward compatibility maintained for v3.0 TTL mode
- [ ] Unit tests pass for all persistent lock and degraded mode scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-version-detection/09-01-SUMMARY.md`
</output>