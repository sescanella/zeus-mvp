# Plan: Implement OT-Based Query Methods for Union Repository

---
phase: 08-backend-data-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
- backend/repositories/union_repository.py
- tests/unit/test_union_repository_ot.py
autonomous: true

must_haves:
  truths:
    - "Unions can be queried directly by OT value"
    - "ARM disponibles are unions where ARM_FECHA_FIN is NULL"
    - "SOLD disponibles require ARM completion first"
  artifacts:
    - path: "backend/repositories/union_repository.py"
      provides: "OT-based query methods"
      contains: "get_by_ot|get_disponibles_arm_by_ot|get_disponibles_sold_by_ot"
    - path: "tests/unit/test_union_repository_ot.py"
      provides: "Unit tests for OT queries"
      min_lines: 80
  key_links:
    - from: "get_by_ot"
      to: "Uniones OT column"
      via: "direct query on Column B"
      pattern: "headers\\[\"OT\"\\]"
    - from: "disponibles methods"
      to: "state validation"
      via: "filtering by fecha_fin fields"
      pattern: "arm_fecha_fin.*None"
---

<objective>
Implement OT-based query methods that directly query Uniones sheet by OT column (Column B).

Purpose: Enable querying unions by work order (OT) as per v4.0 architecture where Uniones.OT is the foreign key.
Output: UnionRepository with get_by_ot and disponibles methods that query directly by OT column.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-backend-data-layer/08-CONTEXT.md
@backend/repositories/union_repository.py
@backend/models/union.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement get_by_ot method</name>
  <files>backend/repositories/union_repository.py</files>
  <action>
    Add get_by_ot method to UnionRepository:
    - Method signature: get_by_ot(ot: str) -> list[Union]
    - Query Uniones sheet directly using OT column (Column B)
    - Use ColumnMapCache to find OT column index dynamically
    - Filter rows where OT column matches the provided ot value
    - Parse each matching row into Union model
    - Return list of Union objects for the OT
    - Return empty list if OT not found
    - NO TAG_SPOOL lookup - query Uniones.OT directly per architecture decision
  </action>
  <verify>Method queries Uniones by OT column directly</verify>
  <done>get_by_ot returns unions for given OT without TAG_SPOOL dependency</done>
</task>

<task type="auto">
  <name>Task 2: Add get_disponibles_arm_by_ot method</name>
  <files>backend/repositories/union_repository.py</files>
  <action>
    Add get_disponibles_arm_by_ot convenience method:
    - Method signature: get_disponibles_arm_by_ot(ot: str) -> list[Union]
    - Call get_by_ot(ot) to fetch all unions for the work order
    - Filter to unions where arm_fecha_fin is None
    - Return flat list of Union objects available for ARM work
    - Return empty list if no disponibles found
  </action>
  <verify>Method filters correctly for ARM disponibles</verify>
  <done>get_disponibles_arm_by_ot returns unions where ARM_FECHA_FIN is NULL</done>
</task>

<task type="auto">
  <name>Task 3: Add get_disponibles_sold_by_ot method</name>
  <files>backend/repositories/union_repository.py</files>
  <action>
    Add get_disponibles_sold_by_ot convenience method:
    - Method signature: get_disponibles_sold_by_ot(ot: str) -> list[Union]
    - Call get_by_ot(ot) to fetch all unions for the work order
    - Filter to unions where arm_fecha_fin is NOT None AND sol_fecha_fin is None
    - Ensures SOLD prerequisites are met (ARM must be completed first)
    - Return flat list of disponible unions for SOLD operation
  </action>
  <verify>Method validates ARM completion before SOLD disponibility</verify>
  <done>get_disponibles_sold_by_ot returns unions ready for SOLD work</done>
</task>

<task type="auto">
  <name>Task 4: Update batch methods to use get_by_ot</name>
  <files>backend/repositories/union_repository.py</files>
  <action>
    Refactor batch_update methods from Plan 01:
    - Update batch_update_arm to use get_by_ot(ot) instead of any TAG_SPOOL logic
    - Update batch_update_sold to use get_by_ot(ot)
    - Update _validate_unions_for_update to use get_by_ot(ot)
    - Ensure all OT-based operations go through centralized get_by_ot method
    - Remove any temporary TAG_SPOOL lookup code if it exists
  </action>
  <verify>All batch methods use get_by_ot consistently</verify>
  <done>Batch methods query by OT, no TAG_SPOOL dependencies remain</done>
</task>

<task type="auto">
  <name>Task 5: Create unit tests for OT queries</name>
  <files>tests/unit/test_union_repository_ot.py</files>
  <action>
    Create comprehensive test file:
    - Test get_by_ot with valid OT returning multiple unions
    - Test get_by_ot with invalid OT returning empty list
    - Test get_disponibles_arm_by_ot filtering logic
    - Test get_disponibles_sold_by_ot with ARM prerequisite check
    - Mock Uniones sheet with OT column in position B
    - Verify ColumnMapCache correctly finds OT column
    - Test edge case: OT with no unions returns empty list gracefully
    - CRITICAL: Verify NO TAG_SPOOL lookups occur
  </action>
  <verify>pytest tests/unit/test_union_repository_ot.py -xvs passes</verify>
  <done>All OT-based query tests pass, confirming direct OT column usage</done>
</task>

</tasks>

<verification>
Run unit tests for OT-based queries:
```bash
source venv/bin/activate
python -m pytest tests/unit/test_union_repository_ot.py -xvs
```

Verify the OT relationship works correctly:
- Check that queries use Uniones.OT column directly
- Confirm disponibles methods return correct filtered unions
- Validate NO TAG_SPOOL dependencies exist
</verification>

<success_criteria>
- [ ] get_by_ot queries Uniones sheet by OT column (Column B) directly
- [ ] get_disponibles_arm_by_ot returns unions where ARM_FECHA_FIN IS NULL
- [ ] get_disponibles_sold_by_ot returns unions where ARM_FECHA_FIN IS NOT NULL AND SOL_FECHA_FIN IS NULL
- [ ] All methods use ColumnMapCache for dynamic column access
- [ ] NO TAG_SPOOL lookups or dependencies exist
</success_criteria>

<output>
After completion, create `.planning/phases/08-backend-data-layer/08-02-SUMMARY.md`
</output>