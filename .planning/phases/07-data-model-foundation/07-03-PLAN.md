---
phase: 07-data-model-foundation
plan: 03
type: execute
wave: 2
depends_on: [07-01, 07-02]
files_modified: [backend/models/union.py, backend/repositories/union_repository.py, tests/unit/test_union_repository.py]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "UnionRepository can read unions from sheet"
    - "UnionRepository can query by TAG_SPOOL"
    - "Union model validates all 18 fields"
  artifacts:
    - path: "backend/models/union.py"
      provides: "Pydantic Union model"
      min_lines: 40
    - path: "backend/repositories/union_repository.py"
      provides: "Repository for Uniones sheet access"
      min_lines: 150
    - path: "tests/unit/test_union_repository.py"
      provides: "Unit tests for repository"
      min_lines: 100
  key_links:
    - from: "union_repository.py"
      to: "sheets_repository.py"
      via: "dependency injection"
      pattern: "SheetsRepository"
    - from: "union_repository.py"
      to: "ColumnMapCache"
      via: "dynamic header mapping"
      pattern: "ColumnMapCache\\.get_or_build"
---

<objective>
Create Union model and repository for accessing Uniones sheet data.

Purpose: Provide data access layer for union-level tracking with dynamic column mapping
Output: Working UnionRepository with Pydantic model and comprehensive tests
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-model-foundation/07-RESEARCH.md
@.planning/phases/07-data-model-foundation/07-01-SUMMARY.md
@.planning/phases/07-data-model-foundation/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Union Pydantic model</name>
  <files>backend/models/union.py</files>
  <action>
    Create a Pydantic model for the Uniones sheet with all 18 fields.

    Model structure:
    ```python
    class Union(BaseModel):
        # Identity
        id: str  # Composite: {TAG_SPOOL}+{N_UNION}
        tag_spool: str  # Foreign key to Operaciones (maintains v3.0 compatibility)
        n_union: int  # 1-20
        dn_union: float  # Diameter in inches
        tipo_union: str  # Union type

        # ARM timestamps
        arm_fecha_inicio: Optional[datetime] = None
        arm_fecha_fin: Optional[datetime] = None
        arm_worker: Optional[str] = None

        # SOLD timestamps
        sol_fecha_inicio: Optional[datetime] = None
        sol_fecha_fin: Optional[datetime] = None
        sol_worker: Optional[str] = None

        # NDT (Non-Destructive Testing)
        ndt_fecha: Optional[datetime] = None
        ndt_status: Optional[str] = None  # APROBADO/RECHAZADO/PENDIENTE

        # Audit fields
        version: str = Field(default_factory=lambda: str(uuid.uuid4()))
        creado_por: str
        fecha_creacion: datetime
        modificado_por: Optional[str] = None
        fecha_modificacion: Optional[datetime] = None

        model_config = ConfigDict(frozen=True)  # Immutable
    ```

    Include field validation:
    - n_union: between 1 and 20
    - dn_union: positive float
    - tag_spool: non-empty string
    - Worker format: "INITIALS(ID)" pattern

    **IMPORTANT NOTE:** Using TAG_SPOOL as the foreign key (not OT) per architecture decision in research (line 221: "Decision: Maintain TAG_SPOOL as PK"). This avoids breaking v3.0 Redis keys, Metadata references, and ~50 existing queries.

    Follow pattern from backend/models/spool.py
  </action>
  <verify>python -c "from backend.models.union import Union; print('Union model imported successfully')"</verify>
  <done>Union model imports without errors and has all 18 fields defined</done>
</task>

<task type="auto">
  <name>Task 2: Create UnionRepository</name>
  <files>backend/repositories/union_repository.py</files>
  <action>
    Create repository class for accessing Uniones sheet data.

    Key methods:
    1. `get_by_spool(tag_spool: str) -> list[Union]`
       - Query all unions for a given spool using TAG_SPOOL as foreign key
       - **Architecture Note:** Uses TAG_SPOOL (not OT) to maintain compatibility with v3.0
       - Use ColumnMapCache for dynamic column lookup
       - Return empty list if no unions found

    2. `get_disponibles(operacion: Literal["ARM", "SOLD"]) -> dict[str, list[Union]]`
       - ARM: Return unions where ARM_FECHA_FIN is NULL
       - SOLD: Return unions where ARM_FECHA_FIN is NOT NULL and SOL_FECHA_FIN is NULL
       - Group by TAG_SPOOL for efficient lookup

    3. `count_completed(tag_spool: str, operacion: Literal["ARM", "SOLD"]) -> int`
       - Count unions with FECHA_FIN != NULL for given operation
       - Used for progress calculation

    4. `sum_pulgadas(tag_spool: str, operacion: Literal["ARM", "SOLD"]) -> float`
       - Sum DN_UNION for completed unions
       - Return with 1 decimal precision

    5. `_row_to_union(row_data: list, column_map: dict) -> Union`
       - Convert sheet row to Union object using dynamic mapping
       - Handle date parsing with backend.utils.date_formatter
       - Handle empty cells gracefully

    Use dependency injection for SheetsRepository (same pattern as MetadataRepository).
    All methods must use ColumnMapCache.get_or_build() - NO hardcoded indices.

    **Critical Design Decision:** TAG_SPOOL is used as the foreign key to Operaciones (column 2 in Uniones sheet) per architecture decision. This maintains compatibility with all v3.0 code, Redis keys, and Metadata references.
  </action>
  <verify>python -c "from backend.repositories.union_repository import UnionRepository; print('Repository imported successfully')"</verify>
  <done>UnionRepository class exists with all required methods</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive unit tests</name>
  <files>tests/unit/test_union_repository.py</files>
  <action>
    Create unit tests for UnionRepository covering:

    1. test_get_by_spool_returns_unions()
       - Mock SheetsRepository.read_worksheet() to return sample data
       - Verify correct unions returned for given TAG_SPOOL
       - Verify filtering works correctly

    2. test_get_by_spool_returns_empty_for_unknown()
       - Verify empty list for non-existent spool

    3. test_get_disponibles_arm()
       - Mock data with mix of completed and pending unions
       - Verify only NULL ARM_FECHA_FIN unions returned

    4. test_get_disponibles_sold()
       - Verify ARM complete but SOLD incomplete unions returned

    5. test_count_completed()
       - Test counting for both ARM and SOLD

    6. test_sum_pulgadas()
       - Verify correct sum with decimal precision

    7. test_handles_missing_columns_gracefully()
       - Test repository doesn't crash if optional columns missing

    8. test_uses_column_map_cache()
       - Verify ColumnMapCache.get_or_build() is called
       - Ensure no hardcoded indices

    9. test_uses_tag_spool_as_foreign_key()
       - Verify TAG_SPOOL (not OT) is used for queries
       - Mock data with different TAG_SPOOL values
       - Ensure correct filtering by TAG_SPOOL

    Use unittest.mock for mocking, follow pattern from tests/unit/test_metadata_repository.py
  </action>
  <verify>PYTHONPATH="$(pwd)" pytest tests/unit/test_union_repository.py -v</verify>
  <done>All tests pass with detailed output showing test names</done>
</task>

</tasks>

<verification>
1. Import Union model: `python -c "from backend.models.union import Union"`
2. Import repository: `python -c "from backend.repositories.union_repository import UnionRepository"`
3. Run tests: `PYTHONPATH="$(pwd)" pytest tests/unit/test_union_repository.py -v`
</verification>

<success_criteria>
- [ ] Union model validates all 18 fields with proper types
- [ ] UnionRepository uses dynamic column mapping exclusively
- [ ] Repository queries by TAG_SPOOL (not OT) per architecture decision
- [ ] All unit tests pass with good coverage
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-model-foundation/07-03-SUMMARY.md`
</output>