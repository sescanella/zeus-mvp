---
phase: 13-performance-validation-and-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [tests/performance/test_api_call_efficiency.py]
autonomous: true

must_haves:
  truths:
    - "System verifies FINALIZAR makes exactly 2 API calls"
    - "System tracks batch_update and append_rows calls separately"
    - "System validates PERF-04 metadata chunking at 900 rows"
  artifacts:
    - path: "tests/performance/test_api_call_efficiency.py"
      provides: "API call counting and efficiency validation"
      min_lines: 120
  key_links:
    - from: "test_api_call_efficiency.py"
      to: "mock_worksheet.batch_update"
      via: "call count verification"
      pattern: "batch_update\\.call_count == 1"
---

<objective>
Validate API call efficiency for PERF-03 and PERF-04 requirements.

Purpose: Ensure FINALIZAR operations make maximum 2 API calls and metadata chunking works correctly.
Output: Tests verifying API call counts and batch operation efficiency.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-performance-validation-and-optimization/13-RESEARCH.md

# Existing test patterns from Phase 8
@tests/integration/test_performance_target.py
@backend/services/union_service.py
@backend/repositories/metadata_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API call counting tests</name>
  <files>tests/performance/test_api_call_efficiency.py</files>
  <action>
    Create comprehensive API call efficiency validation tests.

    Create tests/performance/test_api_call_efficiency.py with:

    1. test_finalizar_makes_exactly_2_api_calls():
       - Mock sheets and metadata repositories
       - Execute FINALIZAR with 10 unions
       - Verify batch_update called exactly once
       - Verify append_rows called exactly once
       - Assert total API calls = 2 (PERF-03)
       - Validate batch_update contains all union updates

    2. test_metadata_chunking_at_900_rows():
       - Create scenario with 1000+ events (triggers chunking)
       - Execute batch metadata logging
       - Verify append_rows called multiple times
       - Verify each chunk ≤ 900 rows (PERF-04)
       - Validate all events logged despite chunking

    3. test_api_calls_scale_linearly():
       - Test with 10, 20, 30, 50 unions
       - Verify API calls remain constant (always 2)
       - Ensure batch size increases but call count doesn't
       - Validate O(1) API complexity regardless of union count

    Use mock verification from Phase 8 patterns, extending with explicit call counting and argument inspection.
  </action>
  <verify>
    Run: pytest tests/performance/test_api_call_efficiency.py -v
    - All tests pass
    - API call counts verified
    - Metadata chunking confirmed
  </verify>
  <done>API call efficiency tests validate PERF-03 (max 2 calls) and PERF-04 (900-row chunks)</done>
</task>

<task type="auto">
  <name>Task 2: Add batch operation validation</name>
  <files>tests/performance/test_api_call_efficiency.py</files>
  <action>
    Enhance tests with detailed batch operation validation.

    Add to test_api_call_efficiency.py:

    1. test_batch_update_field_coverage():
       - Verify batch_update covers all required fields
       - Check ARM_FECHA_FIN, ARM_WORKER for each union
       - Validate A1 notation ranges are correct
       - Ensure no duplicate or missing updates

    2. test_batch_operation_atomicity():
       - Verify all-or-nothing batch behavior
       - Test rollback on partial failure
       - Validate version token updates in single batch

    3. test_no_unnecessary_api_calls():
       - Monitor for redundant reads
       - Check for duplicate writes
       - Verify caching prevents extra API calls
       - Assert minimal API surface usage

    This ensures not just the count but the quality of API calls is optimal.
  </action>
  <verify>
    - Batch operation details validated
    - Field coverage confirmed
    - No redundant API calls detected
  </verify>
  <done>Batch operations validated for completeness and efficiency</done>
</task>

<task type="auto">
  <name>Task 3: Create API call monitoring utilities</name>
  <files>tests/performance/test_api_call_efficiency.py</files>
  <action>
    Add monitoring utilities for ongoing API call tracking.

    Add APICallMonitor class to track calls across tests:

    1. APICallMonitor class:
       - Track all gspread method calls
       - Categorize by operation type (read/write/batch)
       - Calculate API quota consumption
       - Generate efficiency report

    2. Monitoring decorators:
       - @monitor_api_calls decorator for tests
       - Automatic call counting and reporting
       - Warnings for inefficient patterns

    3. Efficiency metrics:
       - Calls per operation ratio
       - Batch efficiency percentage
       - Quota utilization estimate
       - Optimization recommendations

    This provides ongoing visibility into API usage patterns.
  </action>
  <verify>
    - APICallMonitor class implemented
    - Decorator tracks API calls
    - Efficiency report generated
  </verify>
  <done>API call monitoring utilities provide ongoing efficiency tracking</done>
</task>

</tasks>

<verification>
Run API efficiency test suite:
```bash
pytest tests/performance/test_api_call_efficiency.py -v -s
```

Expected results:
- FINALIZAR makes exactly 2 API calls ✓
- Metadata chunks at 900 rows ✓
- Batch operations are atomic ✓
- No redundant API calls ✓
</verification>

<success_criteria>
- API call counts validated for PERF-03 (max 2 calls)
- Metadata chunking verified for PERF-04 (900 rows)
- Batch operation efficiency confirmed
- Monitoring utilities track ongoing API usage
</success_criteria>

<output>
After completion, create `.planning/phases/13-performance-validation-and-optimization/13-02-SUMMARY.md`
</output>