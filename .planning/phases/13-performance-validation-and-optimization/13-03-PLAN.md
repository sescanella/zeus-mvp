---
phase: 13-performance-validation-and-optimization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [tests/performance/test_rate_limit_compliance.py, backend/utils/rate_limiter.py]
autonomous: true

must_haves:
  truths:
    - "System tracks API requests in sliding 1-minute windows"
    - "System stays under 30 writes/min (50% of quota)"
    - "System detects and warns about rate limit approaching"
  artifacts:
    - path: "tests/performance/test_rate_limit_compliance.py"
      provides: "Rate limit validation tests"
      min_lines: 150
    - path: "backend/utils/rate_limiter.py"
      provides: "Rate limit monitoring utilities"
      min_lines: 100
  key_links:
    - from: "rate_limiter.py"
      to: "collections.deque"
      via: "sliding window implementation"
      pattern: "deque\\(\\)"
---

<objective>
Implement rate limit monitoring for PERF-05 requirement.

Purpose: Ensure system stays under 50% of Google Sheets rate limit (30 writes/min vs 60 limit).
Output: Rate limit monitoring with sliding window tracking and compliance validation.
</objective>

<execution_context>
@/Users/sescanella/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sescanella/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-performance-validation-and-optimization/13-RESEARCH.md

# Existing infrastructure
@backend/core/config.py
@backend/services/union_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RateLimitMonitor class</name>
  <files>backend/utils/rate_limiter.py</files>
  <action>
    Create rate limit monitoring utilities with sliding window tracking.

    Create backend/utils/rate_limiter.py with:

    1. RateLimitMonitor class:
       - __init__(window_seconds=60, target_rpm=30)
       - Use collections.deque for efficient sliding window
       - Track requests with timestamps
       - Prune old requests outside window

    2. Core methods:
       - record_request(request_type: str): Log API request
       - get_current_rpm(): Calculate requests per minute
       - is_within_limit(): Check if under target (30 RPM)
       - get_stats(): Return comprehensive statistics
       - get_quota_utilization(): Percentage of 60 RPM quota

    3. Advanced features:
       - Burst detection (rapid request clusters)
       - Predictive warnings (approaching limit)
       - Request type categorization (read/write/batch)
       - Time until quota reset calculation

    Use deque for O(1) append and efficient old-entry removal. Handle edge cases like empty windows and single-request scenarios.
  </action>
  <verify>
    - backend/utils/rate_limiter.py exists
    - RateLimitMonitor class with all methods
    - Imports collections.deque
  </verify>
  <done>RateLimitMonitor class created with sliding window tracking</done>
</task>

<task type="auto">
  <name>Task 2: Implement rate limit compliance tests</name>
  <files>tests/performance/test_rate_limit_compliance.py</files>
  <action>
    Create comprehensive rate limit compliance validation tests.

    Create tests/performance/test_rate_limit_compliance.py with:

    1. test_rate_limit_compliance_under_load():
       - Simulate 30 workers for 10 minutes
       - Each worker performs 2 FINALIZAR/min
       - Track all API calls with RateLimitMonitor
       - Assert stays under 30 writes/min throughout
       - Report quota utilization statistics

    2. test_burst_detection_and_throttling():
       - Simulate burst of 30 requests in 10 seconds
       - Verify burst is detected
       - Check warning is triggered
       - Validate throttling recommendation

    3. test_sliding_window_accuracy():
       - Add requests at specific timestamps
       - Verify old requests pruned correctly
       - Check RPM calculation accuracy
       - Validate window boundary conditions

    4. test_multi_worker_concurrency():
       - Simulate realistic concurrent worker patterns
       - Model shift changes (everyone starts together)
       - Verify no quota exhaustion during peaks
       - Check average vs peak utilization

    Use time.sleep() and datetime manipulation to simulate realistic timing patterns.
  </action>
  <verify>
    Run: pytest tests/performance/test_rate_limit_compliance.py -v
    - All tests pass
    - Rate limit compliance verified
    - Statistics reported
  </verify>
  <done>Rate limit compliance tests validate PERF-05 (< 50% quota)</done>
</task>

<task type="auto">
  <name>Task 3: Add production monitoring integration</name>
  <files>backend/utils/rate_limiter.py</files>
  <action>
    Enhance rate limiter with production monitoring capabilities.

    Add to rate_limiter.py:

    1. GlobalRateLimitMonitor singleton:
       - Single instance across application
       - Thread-safe with threading.Lock
       - Automatic integration points

    2. Monitoring hooks:
       - Auto-track gspread operations
       - Log warnings to application logs
       - Export metrics for monitoring systems
       - Prometheus-compatible metrics format

    3. Adaptive throttling:
       - calculate_delay(): Return sleep time if approaching limit
       - implement_backoff(): Exponential backoff on high utilization
       - get_recommendations(): Suggest optimizations

    4. Reporting utilities:
       - generate_report(): Daily/hourly statistics
       - export_metrics(): JSON/CSV export
       - alert_thresholds(): Configurable warning levels

    This enables production monitoring and proactive rate limit management.
  </action>
  <verify>
    - GlobalRateLimitMonitor singleton implemented
    - Thread-safe operations
    - Monitoring hooks available
  </verify>
  <done>Production monitoring integration enables real-time rate limit tracking</done>
</task>

</tasks>

<verification>
Run rate limit compliance tests:
```bash
pytest tests/performance/test_rate_limit_compliance.py -v -s
```

Expected output:
- Rate stays under 30 writes/min ✓
- Burst detection working ✓
- Sliding window accurate ✓
- Multi-worker scenarios pass ✓
</verification>

<success_criteria>
- RateLimitMonitor tracks requests in sliding windows
- Tests validate PERF-05 (< 50% quota usage)
- Burst detection prevents quota exhaustion
- Production monitoring ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/13-performance-validation-and-optimization/13-03-SUMMARY.md`
</output>